#!/usr/bin/perl -w


=head1 NAME

sift - A scriptable IMAP utility program.

=cut

=head1 SYNOPSIS

  Connection Options:

   --username     Specify the username to login to IMAP with.
   --password     Specify the matching password for the specified username.
   --server       The server to connect with.

  Misc Options:

   --ssl          Force the use of SSL.
   --execute      Specify a rule to execute directly.

=cut


=head1 ABOUT

  sift is an IMAP client utility which allows you to manipulate
 a remote mailbox via a collection of simple rules.

  The program has a number of built in primitives for selecting
 messages from the remote mailbox, and for performing simple
 actions upon them.

  For selection you may:

=over 8

=item Search based on flags ("new" vs. "read")

=item Search based on message senders.

=item Search based on message subjects.

=item Search based on message bodies.

=back


  Once you have selected a number of messages you may do a couple of
 different things:


=over 8

=item Copy/Move messages into a new folder.

=item Delete messages

=item Change flags ("new" vs. "read")

=item Execute programs with the message bodies as input.

=back


  It is designed to be simple to understand and use, but it might not
 be flexible enough for complex cases.

=cut


=head1 SAMPLE USAGE

  As many options may be specified directly upon the command line,
 it is possible to conduct many things directly.

  The following example will delete all messages contained in the
 'spam' folder of a given Google Mail account:

=for example begin

   sift --username=foo --password=bar --server=imap.gmail.com \
    --ssl --execute "folder:[Google#Mail]/Spam delete" --verbose

=for example end

  This example might look simpler as an input file.  If you save
 the following into a file you may execute it via "sift filename":

=for example begin

username:  foo
passsword: bar
server:    imap.gmail.com

#
#  Delete all messages in the spam folder.
#
folder:[Google#Mail]/Spam delete

=for example end

  More complex rules may be constructed, as described in the README
 file accompanying this release.

=cut



=head1 AUTHOR

 Steve
 --
 http://www.steve.org.uk/

=cut

=head1 LICENSE

Copyright (c) 2008 by Steve Kemp.  All rights reserved.

This module is free software;
you can redistribute it and/or modify it under
the same terms as Perl itself.
The LICENSE file contains the full text of the license.

=cut



use strict;
use warnings;
use File::Temp qw/ tempfile /;
use Getopt::Long;
use Net::IMAP::Simple;
use Net::IMAP::Simple::SSL;
use Pod::Usage;



#
#  Configuration variables.
#
my %CONFIG;


#
#  Release:  Set by "make release"
#
$CONFIG{ 'version' } = 'UNRELEASED';


#
#  Global connection handle
#
my $imap;



#
#  Parse command line arguments.
#
parseCommandLineArguments();


#
#  Early login?
#
if ( $CONFIG{ 'server' } && $CONFIG{ 'username' } && $CONFIG{ 'password' } )
{

    #
    #  Are we using SSL?
    #
    my $ssl = $CONFIG{ 'ssl' } || 0;
    $ssl = 1 if ( $CONFIG{ 'server' } =~ /imap\.gmail\.com/i );

    # login
    $imap = login( $CONFIG{ 'server' },
                   $CONFIG{ 'username' },
                   $CONFIG{ 'password' }, $ssl );

}
else
{
    $imap = undef;
}



#
#  Are we running directly?
#
if ( $CONFIG{ 'execute' } )
{

    # If we've logged in OK then we can run the snippet.
    if ( defined $imap )
    {

        # run the "script"
        processRule( $CONFIG{ 'execute' } );

    }
    else
    {
        print "Please specify username, password and server to connect to.\n";
    }

    # logout
    $imap->quit() if ( defined($imap) );

    exit;
}



#
#  Are there files specified upon the command line?
#
foreach my $file (@ARGV)
{

    #
    #  If we've not been given login details then we need to find
    # them in the script file.  Use them to login.
    #
    if ( !defined($imap) )
    {
        my $username = findUsername($file) || undef;
        my $password = findPassword($file) || undef;
        my $server   = findServer($file)   || undef;
        my $ssl      = $CONFIG{ 'ssl' }    || 0;

        if ( !defined($username) )
        {
            print "Failed to find username in the file $file\n";
            print "aborting\n";
            exit;
        }
        if ( !defined($password) )
        {
            print "Failed to find password in the file $file\n";
            print "aborting\n";
            exit;
        }
        if ( !defined($server) )
        {
            print "IMAP server unknown.\n";
            exit;
        }

        #
        #  GMail requires the use of SSL.
        #
        $ssl = 1 if ( $server =~ /imap\.gmail\.com/i );

        #
        #  Login
        #
        $imap = login( $server, $username, $password, $ssl );
    }

    #
    #  Run the file.
    #
    processRules($file);

    #
    #  Logout.
    #
    $imap->quit();

    #
    #  Reset so that we can reconnect properly
    #
    $imap = undef;
}



#
#  All done.
#
exit;



=begin doc

  Process the command line arguments.

=end doc

=cut

sub parseCommandLineArguments
{
    my $HELP    = 0;
    my $MANUAL  = 0;
    my $VERSION = 0;


    #
    #  Parse options.
    #
    GetOptions(

        # Help options
        "help",    \$HELP,
        "manual",  \$MANUAL,
        "version", \$VERSION,
        "verbose", \$CONFIG{ 'verbose' },


        # login details
        "user=s",   \$CONFIG{ 'username' },
        "pass=s",   \$CONFIG{ 'password' },
        "server=s", \$CONFIG{ 'server' },

        # use SSL?
        "ssl", \$CONFIG{ 'ssl' },

        # execute directly?
        "execute=s", \$CONFIG{ 'execute' },

    );

    pod2usage(1) if $HELP;
    pod2usage( -verbose => 2 ) if $MANUAL;

    if ($VERSION)
    {
        print "sift v$CONFIG{'version'}\n";
        exit;
    }
}



=begin doc

  Find the username from the given configuration script / file.

=end doc

=cut

sub findUsername
{
    my ($file) = (@_);

    return ( findLoginField( "username", $file ) );
}


=begin doc

  Find the password from the given configuration file / script.

=end doc

=cut

sub findPassword
{
    my ($file) = (@_);

    return ( findLoginField( "password", $file ) );
}


=begin doc

  Find the server from the given configuration file / script.

=end doc

=cut

sub findServer
{
    my ($file) = (@_);

    return ( findLoginField( "server", $file ) );
}



=begin doc

  Find username / password details from our configuration file.

=end doc

=cut

sub findLoginField
{
    my ( $field, $file ) = (@_);

    open( INPUT, "<", $file )
      or die "failed to read $file - $!";

    my $result = undef;

    while ( my $line = <INPUT> )
    {
        next if ( !$line );
        chomp($line);

        if (    ( $line =~ /^\Q$field\E:(.*)/i )
             && ( !defined($result) ) )
        {
            $result = $1;
        }
    }
    close(INPUT);

    $result =~ s/^\s+// if ( defined($result) );
    $result =~ s/\s+$// if ( defined($result) );

    return ($result);
}



=begin doc

  Login to the remote server.

=end doc

=cut

sub login
{
    my ( $server, $user, $pass, $ssl ) = (@_);

    $CONFIG{ 'verbose' } && print "Logging in: $user\@$server [SSL: $ssl]\n";

    #
    #  Connect
    #
    my $imap;

    if ($ssl)
    {
        $imap = Net::IMAP::Simple::SSL->new($server)
          or die "Unable to connect to IMAP server: '$server'.\n";
    }
    else
    {
        $imap = Net::IMAP::Simple->new($server)
          or die "Unable to connect to IMAP server: '$server'.\n";
    }

    #
    # Login
    #
    $imap->login( $user, $pass )
      or die "Login failed :" . $imap->errstr . "\n";

    $CONFIG{ 'verbose' } && print "\tOK\n";
    return ($imap);
}



=begin doc

  Read the specified configuration file, and process each line which
 appears to be valid.

=end doc

=cut

sub processRules
{
    my ($file) = (@_);

    open( INP, "<", $file )
      or die "failed to read : $file - $!";

    while ( my $line = <INP> )
    {

        # skip empty lines and comments.
        next if ( !$line );
        next if ( $line =~ /^#/ );

        # look for lines starting with 'folder'
        next if ( $line !~ /^folder/ );

        # ok we have a valid rule line, process it.
        processRule($line);
    }

    close(INP);
}



=begin doc

  Process a single rule-line read from the configuration file.

=end doc

=cut

sub processRule
{
    my ($line) = (@_);

    #
    #  The stack of messages we've currently got selected.
    #
    my @messages;

    #
    #  The count of messages in the current folder.
    #
    my $count;

    #
    #  Break the list of rules up into a collection of space-separated
    # tokens.
    #
    foreach my $token ( split( / /, $line ) )
    {

        #
        #  Change folder.  Mark all messages as current.
        #
        if ( $token =~ /folder:(.*)/i )
        {
            my $folder = $1;

            #
            #  '#' -> ' '
            #
            $folder =~ s/([^#])#([^#])/$1 $2/g if ($folder);

            #
            #  '##' -> '#'.
            #
            $folder =~ s/##/#/g if ($folder);

            #
            #  Select the folder.
            #
            $CONFIG{ 'verbose' } && print "Selecting folder: $folder\n";
            $count = $imap->select($folder);
            if ( !defined $count )
            {
                print "\tSelecting folder '$folder' failed\n";
                print "\tThe folder is probably empty\n";
                exit;
            }

            #
            # Show message count
            #
            $CONFIG{ 'verbose' } && print "\tFound $count messages\n";
            foreach my $id ( 1 .. $count )
            {
                push( @messages, $id );
            }
        }
        elsif ( $token =~ /status:(.*)/i )
        {

            #
            #  Update current stack of messages to only
            # be those that are of the given status.
            #
            my $status = $1;
            if (    ( $status =~ /^new$/i )
                 || ( $status =~ /^unread$/i ) )
            {
                $CONFIG{ 'verbose' } && print "Finding unread messages\n";
                @messages = findUnread($count);
                my $c = scalar(@messages);
                $CONFIG{ 'verbose' } && print "\tFound $c messages\n";
            }
            if (    ( $status =~ /^old$/i )
                 || ( $status =~ /^read$/i ) )
            {
                $CONFIG{ 'verbose' } && print "Finding old messages\n";
                @messages = findRead($count);
                my $c = scalar(@messages);
                $CONFIG{ 'verbose' } && print "\tFound $c messages\n";
            }
        }
        elsif ( $token =~ /mark:(.*)/i )
        {

            #
            #  No option if there are no messages.
            #
            my $count = scalar(@messages);
            if ( !$count )
            {
                next;
            }

            #
            #  Mark all the currently selected messages as either
            # "new" or "read".
            #
            my $state = $1;
            if (    ( $state =~ /^new$/i )
                 || ( $state =~ /^read$/i ) )
            {
                $CONFIG{ 'verbose' } && print "Marking messages as read\n";
                foreach my $id (@messages)
                {
                    $CONFIG{ 'verbose' } && print "\t:$id\n";
                    $imap->_process_cmd(
                                      cmd => [STORE => qq[$id +FLAGS (\\Seen)]],
                                      final   => sub {1},
                                      process => sub { },
                    );
                }
            }
            if (    ( $state =~ /^unread$/i )
                 || ( $state =~ /^old$/i ) )
            {
                $CONFIG{ 'verbose' } && print "Marking messages as unread\n";
                foreach my $id (@messages)
                {
                    $CONFIG{ 'verbose' } && print "Msg: $id\n";
                    $imap->_process_cmd(
                               cmd => [STORE => qq[$id -FLAGS.SILENT (\\Seen)]],
                               final   => sub {1},
                               process => sub { },
                    );
                }
            }
        }
        elsif ( $token =~ /subject:(.*)/i )
        {

            #
            #  Filter all current messages to remove those that
            # don't match the given subject string.
            #
            my $subject = $1;
            $CONFIG{ 'verbose' }
              && print "Looking messages with subject matching: $subject\n";

            my @matches;

            foreach my $id (@messages)
            {
                my $msg = $imap->get($id);

                if ($msg)
                {
                    my $found = 0;

                    foreach my $line (@$msg)
                    {
                        next if ($found);

                        if (    ( $line =~ /^Subject:/ )
                             && ( $line =~ /\Q$subject\E/i )
                             && ( !$found ) )
                        {
                            push( @matches, $id );
                            print "\tmatch: found\n";
                            $found += 1;
                        }
                    }
                }
            }
            @messages = @matches;
            $CONFIG{ 'verbose' }
              && print "\tFound "
              . scalar(@messages)
              . " matching message(s)\n";
        }
        elsif ( $token =~ /from:(.*)/i )
        {

            #
            #  Filter all current messages to remove those that
            # don't match the given subject string.
            #
            my $sender = $1;
            $CONFIG{ 'verbose' }
              && print "Looking messages with sender matching: $sender\n";

            my @matches;

            foreach my $id (@messages)
            {
                print "Testing message: $id\n";
                my $msg = $imap->get($id);

                if ($msg)
                {
                    my $found = 0;

                    foreach my $line (@$msg)
                    {
                        next if ($found);

                        if (    ( $line =~ /^From:/ )
                             && ( $line =~ /\Q$sender\E/i )
                             && ( !$found ) )
                        {
                            push( @matches, $id );
                            print "\tmatch: found\n";
                            $found += 1;
                        }
                    }
                }
            }
            @messages = @matches;
            $CONFIG{ 'verbose' }
              && print "\tFound "
              . scalar(@messages)
              . " matching message(s)\n";
        }
        elsif ( $token =~ /execonce:(.*)/i )
        {

            #
            #  Execute the named program only once, regardless of
            # the number of matches.
            #
            my $prog = $1;
            $prog =~ s/^\s+//;
            $prog =~ s/\s+$//;


            my $count = scalar(@messages);
            if ($count)
            {
                $CONFIG{ 'verbose' } && print "Executing program: $prog\n";
                system($prog );
            }

        }
        elsif ( $token =~ /exec:(.*)/i )
        {

            #
            #  Execute the named program once for each selected
            # message.
            #
            my $prog = $1;
            $prog =~ s/^\s+//;
            $prog =~ s/\s+$//;

            #
            #  No option if there are no messages.
            #
            my $count = scalar(@messages);
            if ( !$count )
            {
                next;
            }


            $CONFIG{ 'verbose' } && print "Executing program: $prog\n";

            foreach my $id (@messages)
            {
                $CONFIG{ 'verbose' } && print "\t$id\n";
                my $msg = $imap->get($id);

                if ($msg)
                {
                    my ( $fh, $filename ) = tempfile();

                    foreach my $m (@$msg)
                    {
                        print $fh $m;
                    }
                    close($fh);

                    system("cat $filename | $prog");
                    unlink($filename);
                }
            }
        }
        elsif ( $token =~ /delete/i )
        {

            #
            #  No option if there are no messages.
            #
            my $count = scalar(@messages);
            if ( !$count )
            {
                next;
            }

            #
            #  Delete all currently selected messages.
            #
            $CONFIG{ 'verbose' } && print "Deleting messages\n";

            foreach my $id (@messages)
            {
                $CONFIG{ 'verbose' } && print "\t$id\n";
                $imap->delete($id);
            }
        }
        elsif ( $token =~ /dump/i )
        {

            #
            #  No option if there are no messages.
            #
            my $count = scalar(@messages);
            if ( !$count )
            {
                next;
            }

            #
            #  Dump details of the message
            #
            my $to      = '';
            my $from    = '';
            my $subject = '';

            foreach my $id (@messages)
            {
                my $msg = $imap->get($id);

                if ($msg)
                {
                    foreach my $line (@$msg)
                    {
                        $subject = $1 if ( $line =~ /^Subject: (.*)/i );
                        $from    = $1 if ( $line =~ /^From: (.*)/i );
                        $to      = $1 if ( $line =~ /^To: (.*)/i );
                    }

                    print <<EOF;
[$id]
	To: $to
	From: $from
	Subject: $subject
EOF
                }
            }

        }
        elsif ( $token =~ /move:(.*)/i )
        {

            #
            #  Move all selected messages to the specified folder.
            #
            my $dest = $1;
            $dest =~ s/^\s+//;
            $dest =~ s/\s+$//;


            #
            #  No option if there are no messages.
            #
            my $count = scalar(@messages);
            if ( !$count )
            {
                next;
            }

            $CONFIG{ 'verbose' } && print "Moving messages to folder: $dest\n";

            foreach my $id (@messages)
            {
                print "\t$id\n";
                if ( $imap->copy( $id, $dest ) )
                {
                    $imap->delete($id);
                }
            }
        }
        elsif ( $token =~ /copy:(.*)/i )
        {

            #
            #  Copy all selected messages to the specified folder.
            #
            my $dest = $1;
            $dest =~ s/^\s+//;
            $dest =~ s/\s+$//;

            #
            #  No option if there are no messages.
            #
            my $count = scalar(@messages);
            if ( !$count )
            {
                next;
            }

            $CONFIG{ 'verbose' } && print "Copying messages to folder: $dest\n";

            foreach my $id (@messages)
            {
                $CONFIG{ 'verbose' } && print "\t$id\n";
                $imap->copy( $id, $dest );
            }
        }
    }
}



=begin doc

  Primitive to return a list of message IDs which are messages that
 are not read.

=end doc

=cut

sub findUnread
{
    my ($count) = (@_);
    my $sh = $imap->{ sock };
    print $sh "A$count SEARCH unseen\r\n";

    my @matches;
    while ( my $resp = $sh->getline() )
    {
        last if ( $resp =~ /OK/ );

        if ( $resp =~ /SEARCH / )
        {
            if ($resp) {chomp($resp);}

            foreach my $tok ( split( / /, $resp ) )
            {
                if ( $tok =~ /^([0-9]+)/ )
                {
                    $tok = $1;
                }
                push( @matches, $tok ) if ( $tok =~ /^([0-9]+)$/ );
            }
        }
    }
    return (@matches);
}



=begin doc

  Primitive:  Find the messages IDs of messages which have been
 read in the current folder.

=end doc

=cut

sub findRead
{
    my ($count) = (@_);
    my $sh = $imap->{ sock };
    print $sh "A$count SEARCH seen\r\n";

    my @matches;
    while ( my $resp = $sh->getline() )
    {
        last if ( $resp =~ /OK/ );

        if ($resp) {chomp($resp);}

        if ( $resp =~ /SEARCH / )
        {
            foreach my $tok ( split( / /, $resp ) )
            {
                if ( $tok =~ /^([0-9]+)/ )
                {
                    $tok = $1;
                }

                push( @matches, $tok ) if ( $tok =~ /^([0-9]+)$/ );
            }
        }
    }

    return (@matches);
}
