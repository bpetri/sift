#!/usr/bin/perl -w


=head1 NAME

sift - A scriptable IMAP utility program.

=cut

=head1 SYNOPSIS

  Connection Options:

   --username     Specify the username to login to IMAP with.
   --password     Specify the matching password for the specified username.
   --server       The server to connect with.

  Misc Options:

   --dry-run      Don't execute anything.
   --execute      Specify a rule to execute directly.
   --no-cache     Don't cache messages.
   --ssl          Force the use of SSL.

=cut


=head1 ABOUT

  sift is an IMAP client utility which allows you to manipulate
 a remote mailbox via a collection of simple rules.

  The program has a number of built in primitives for selecting
 messages from the remote mailbox, and for performing simple
 actions upon them.

  For selection you may:

=over 8

=item Search based on flags ("new" vs. "read")

=item Search based on message senders.

=item Search based on message subjects.

=item Search based on message bodies.

=back


  Once you have selected a number of messages you may do a couple of
 different things:


=over 8

=item Copy/Move messages into a new folder.

=item Delete messages

=item Change flags ("new" vs. "read")

=item Execute programs with the message bodies as input.

=back


  It is designed to be simple to understand and use, but it might not
 be flexible enough for complex cases.

=cut


=head1 SAMPLE USAGE

  As many options may be specified directly upon the command line,
 it is possible to conduct many things directly.

  The following example will delete all messages contained in the
 'spam' folder of a given Google Mail account:

=for example begin

   sift --username=foo --password=bar --server=imap.gmail.com \
    --ssl --execute "folder:[Google#Mail]/Spam delete" --verbose

=for example end

  This example might look simpler as an input file.  If you save
 the following into a file you may execute it via "sift filename":

=for example begin

username:  foo
passsword: bar
server:    imap.gmail.com

#
#  Delete all messages in the spam folder.
#
folder:[Google#Mail]/Spam delete

=for example end

  More complex rules may be constructed, as described in the README
 file accompanying this release.

=cut



=head1 AUTHOR

 Steve
 --
 http://www.steve.org.uk/

=cut

=head1 LICENSE

Copyright (c) 2008 by Steve Kemp.  All rights reserved.

This module is free software;
you can redistribute it and/or modify it under
the same terms as Perl itself.
The LICENSE file contains the full text of the license.

=cut



use strict;
use warnings;
use File::Temp qw/ tempfile tempdir /;
use Getopt::Long;
use Net::IMAP::Simple;
use Net::IMAP::Simple::SSL;
use Pod::Usage;



#
#  Configuration variables.
#
my %CONFIG;


#
#  Release:  Set by "make release"
#
$CONFIG{ 'version' } = 'UNRELEASED';


#
#  Global connection handle
#
my $imap;



#
#  Parse command line arguments.
#
parseCommandLineArguments();


#
#  Early login?
#
if ( $CONFIG{ 'server' } && $CONFIG{ 'username' } && $CONFIG{ 'password' } )
{

    #
    #  Are we using SSL?
    #
    my $ssl = $CONFIG{ 'ssl' } || 0;
    $ssl = 1 if ( $CONFIG{ 'server' } =~ /imap\.gmail\.com/i );

    # login
    $imap = login( $CONFIG{ 'server' },
                   $CONFIG{ 'username' },
                   $CONFIG{ 'password' }, $ssl );

}
else
{
    $imap = undef;
}



#
#  Are we running directly?
#
if ( $CONFIG{ 'execute' } )
{

    # If we've logged in OK then we can run the snippet.
    if ( defined $imap )
    {

        # run the "script"
        processRule( $CONFIG{ 'execute' } );

    }
    else
    {
        print "Please specify username, password and server to connect to.\n";
    }

    # logout
    $imap->quit() if ( defined($imap) );

    exit;
}



#
#  Are there files specified upon the command line?
#
foreach my $file (@ARGV)
{

    #
    #  If we've not been given login details then we need to find
    # them in the script file.  Use them to login.
    #
    if ( !defined($imap) )
    {

        #
        #  We need to find the login details.
        #
        #  Ideally these will come from the file, to allow them to
        # override the command line.
        #  If they aren't in the file then we'll use the command
        # line version(s) as a fall-back.
        #
        my $username = findUsername($file) || $CONFIG{ 'username' } || undef;
        my $password = findPassword($file) || $CONFIG{ 'password' } || undef;
        my $server   = findServer($file)   || $CONFIG{ 'server' }   || undef;
        my $ssl      = $CONFIG{ 'ssl' }    || 0;

        if ( !defined($username) )
        {
            print "Failed to find username in the file $file\n";
            print "aborting\n";
            exit;
        }
        if ( !defined($password) )
        {
            print "Failed to find password in the file $file\n";
            print "aborting\n";
            exit;
        }
        if ( !defined($server) )
        {
            print "IMAP server unknown.\n";
            exit;
        }

        #
        #  GMail requires the use of SSL.
        #
        $ssl = 1 if ( $server =~ /imap\.gmail\.com/i );

        #
        #  Login
        #
        $imap = login( $server, $username, $password, $ssl );
    }

    #
    #  Run the file.
    #
    processRules($file);

    #
    #  Logout.
    #
    $imap->quit();

    #
    #  Reset so that we can reconnect properly
    #
    $imap = undef;
}



#
#  All done.
#
exit;



=begin doc

  Process the command line arguments.

=end doc

=cut

sub parseCommandLineArguments
{
    my $HELP    = 0;
    my $MANUAL  = 0;
    my $VERSION = 0;


    #
    #  Parse options.
    #
    if (
        !GetOptions(

            # Help options
            "help",    \$HELP,
            "manual",  \$MANUAL,
            "version", \$VERSION,
            "verbose", \$CONFIG{ 'verbose' },


            # login details
            "user=s",   \$CONFIG{ 'username' },
            "pass=s",   \$CONFIG{ 'password' },
            "server=s", \$CONFIG{ 'server' },

            # dry run?
            "dry-run", \$CONFIG{ 'dry-run' },

            # caching related
            "no-cache",     \$CONFIG{ 'no-cache' },
            "global-cache", \$CONFIG{ 'global-cache' },

            # execute directly?
            "execute=s", \$CONFIG{ 'execute' },

            # use SSL?
            "ssl", \$CONFIG{ 'ssl' },

        )
      )
    {
        exit;
    }

    pod2usage(1) if $HELP;
    pod2usage( -verbose => 2 ) if $MANUAL;

    if ($VERSION)
    {
        print "sift v$CONFIG{'version'}\n";
        exit;
    }
}



=begin doc

  Find the username from the given configuration script / file.

=end doc

=cut

sub findUsername
{
    my ($file) = (@_);

    return ( findLoginField( "username", $file ) );
}


=begin doc

  Find the password from the given configuration file / script.

=end doc

=cut

sub findPassword
{
    my ($file) = (@_);

    return ( findLoginField( "password", $file ) );
}


=begin doc

  Find the server from the given configuration file / script.

=end doc

=cut

sub findServer
{
    my ($file) = (@_);

    return ( findLoginField( "server", $file ) );
}



=begin doc

  Find username / password details from our configuration file.

=end doc

=cut

sub findLoginField
{
    my ( $field, $file ) = (@_);

    open( INPUT, "<", $file )
      or die "failed to read $file - $!";

    my $result = undef;

    while ( my $line = <INPUT> )
    {
        next if ( !$line );
        chomp($line);

        if (    ( $line =~ /^\Q$field\E:(.*)/i )
             && ( !defined($result) ) )
        {
            $result = $1;
        }
    }
    close(INPUT);

    $result =~ s/^\s+// if ( defined($result) );
    $result =~ s/\s+$// if ( defined($result) );

    return ($result);
}



=begin doc

  Login to the remote server, and return a connected IMAP object if
 that succeeded.  Error on failure.

=end doc

=cut

sub login
{
    my ( $server, $user, $pass, $ssl ) = (@_);

    $CONFIG{ 'verbose' } && print "Logging in: $user\@$server [SSL: $ssl]\n";

    #
    #  Connect
    #
    my $imap;

    if ($ssl)
    {
        $imap = Net::IMAP::Simple::SSL->new($server)
          or die "Unable to connect to IMAP server: '$server'.\n";
    }
    else
    {
        $imap = Net::IMAP::Simple->new($server)
          or die "Unable to connect to IMAP server: '$server'.\n";
    }

    #
    # Login
    #
    $imap->login( $user, $pass )
      or die "Login failed :" . $imap->errstr . "\n";

    return ($imap);
}



=begin doc

  Read the specified rule-file, and process each line which
 appears to be valid.

=end doc

=cut

sub processRules
{
    my ($file) = (@_);

    open( INP, "<", $file )
      or die "failed to read : $file - $!";

    while ( my $line = <INP> )
    {

        # skip empty lines and comments.
        next if ( !$line );
        next if ( $line =~ /^#/ );

        # look for lines starting with 'folder'
        next if ( $line !~ /^folder/ );

        # ok we have a valid rule line, process it.
        processRule($line);
    }

    close(INP);
}



=begin doc

  Process a single rule-line read from the configuration file.

  The line is split into tokens and each one is executed in order,
 if it is recognised.

=end doc

=cut

sub processRule
{
    my ($line) = (@_);

    #
    #  The stack of messages we've currently got selected.
    #
    my @messages;

    #
    #  The count of messages in the current folder.
    #
    my $count;

    #
    #  Break the list of rules up into a collection of space-separated
    # tokens.
    #
    foreach my $token ( split( /[ \t]/, $line ) )
    {

        #
        #  Skip blank tokens
        #
        next if ( !length($token) || ( $token =~ /^([\t ]+)$/ ) );

        $CONFIG{ 'verbose' } && print "TOKEN: $token\n";

        #
        #  Change folder.  Mark all messages as current.
        #
        if ( $token =~ /folder:(.*)/i )
        {
            my $folder = $1;

            #
            # Expansion:
            #
            #  "#"  -> " "
            #  "##" -> "#"
            #
            $folder =~ s/([^#])#([^#])/$1 $2/g if ($folder);
            $folder =~ s/##/#/g if ($folder);

            #
            #  Ensure we got an argument.
            #
            if ( !$folder )
            {
                print "Error - folder: requires an argument\n";
                next;
            }

            #
            #  Dry run?  Stop here.
            #
            next if ( $CONFIG{ 'dry-run' } );

            #
            #
            #  Select the folder.
            #
            $CONFIG{ 'verbose' } && print "Selecting folder: $folder\n";

            #
            #  Remove existing cache, if present.
            #
            if (    ( $CONFIG{ 'cache' } )
                      && ( -d $CONFIG{ 'cache' } )
                    && ( !$CONFIG{'global-cache'} ) )
            {
                $CONFIG{ 'verbose' } && print "Removing old folder cache\n";
                system("rm -rf $CONFIG{'cache'}");
            }

            #
            #  Create folder cache
            #
            $CONFIG{ 'cache' } = tempdir( CLEANUP => 1 )
              unless ( $CONFIG{ 'no-cache' } );


            $count = $imap->select($folder);
            if ( !defined $count )
            {
                print "\tSelecting folder '$folder' failed\n";
                print "\tThe folder is probably empty\n";
                exit;
            }

            #
            # Show message count
            #
            $CONFIG{ 'verbose' } && print "\tFound $count messages\n";
            foreach my $id ( 1 .. $count )
            {
                push( @messages, $id );
            }
        }
        elsif ( $token =~ /status:(.*)/i )
        {

            #
            #  Update current stack of messages to only
            # be those that are of the given status.
            #
            my $status = $1;

            #
            #  Ensure we got an argument.
            #
            if ( !$status )
            {
                print "Error - status: requires an argument\n";
                next;
            }

            #
            #  Dry run?  Stop here.
            #
            next if ( $CONFIG{ 'dry-run' } );


            if (    ( $status =~ /^new$/i )
                 || ( $status =~ /^unread$/i ) )
            {
                $CONFIG{ 'verbose' } && print "Finding unread messages\n";
                @messages = findUnread($count);
                my $c = scalar(@messages);
                $CONFIG{ 'verbose' } && print "\tFound $c messages\n";
            }
            elsif (    ( $status =~ /^old$/i )
                    || ( $status =~ /^read$/i ) )
            {
                $CONFIG{ 'verbose' } && print "Finding old messages\n";
                @messages = findRead($count);
                my $c = scalar(@messages);
                $CONFIG{ 'verbose' } && print "\tFound $c messages\n";
            }
            else
            {
                print "WARNING: Ignoring unknown status type '$status'\n";
            }
        }
        elsif ( $token =~ /mark:(.*)/i )
        {

            #
            #  No option if there are no messages.
            #
            my $count = scalar(@messages);
            if ( !$count )
            {
                next;
            }

            #
            #  Mark all the currently selected messages as either
            # "new" or "read".
            #
            my $state = $1;

            #
            #  Ensure we got an argument.
            #
            if ( !$state )
            {
                print "Error - status: requires an argument\n";
                next;
            }

            #
            #  Dry run?  Stop here.
            #
            next if ( $CONFIG{ 'dry-run' } );

            if (    ( $state =~ /^new$/i )
                 || ( $state =~ /^read$/i ) )
            {
                $CONFIG{ 'verbose' } && print "Marking messages as read\n";
                foreach my $id (@messages)
                {
                    $CONFIG{ 'verbose' } && print "\t:$id\n";
                    $imap->_process_cmd(
                                      cmd => [STORE => qq[$id +FLAGS (\\Seen)]],
                                      final   => sub {1},
                                      process => sub { },
                    );
                }
            }
            elsif (    ( $state =~ /^unread$/i )
                    || ( $state =~ /^old$/i ) )
            {
                $CONFIG{ 'verbose' } && print "Marking messages as unread\n";
                foreach my $id (@messages)
                {
                    $CONFIG{ 'verbose' } && print "Msg: $id\n";
                    $imap->_process_cmd(
                               cmd => [STORE => qq[$id -FLAGS.SILENT (\\Seen)]],
                               final   => sub {1},
                               process => sub { },
                    );
                }
            }
            else
            {
                print "WARNING:  Ignoring unknown status type '$state'\n";
            }
        }
        elsif ( $token =~ /\!*subject:(.*)/i )
        {

            #
            #  Filter all current messages to remove those that
            # don't match the given subject string.
            #
            my $subject = $1;

            #
            # Expansion:
            #
            #  "#"  -> " "
            #  "##" -> "#"
            #
            $subject =~ s/([^#])#([^#])/$1 $2/g if ($subject);
            $subject =~ s/##/#/g if ($subject);

            #
            #  Ensure we got an argument.
            #
            if ( !$subject )
            {
                print "Error - subject: requires an argument\n";
                next;
            }

            #
            #  Dry run?  Stop here.
            #
            next if ( $CONFIG{ 'dry-run' } );

            #
            #  Inverted search?
            #
            my $invert = 0;
            $invert = 1 if ( $token =~ /^\!/ );


            if ( $CONFIG{ 'verbose' } )
            {
                if ($invert)
                {
                    print
                      "Looking messages with subject NOT matching: $subject\n";
                }
                else
                {
                    print "Looking messages with subject matching: $subject\n";
                }
            }

            my @matches;

            foreach my $id (@messages)
            {
                my $msg = getMessage( $imap, $id );

                if ($msg)
                {
                    if (
                         matchMessageHeader( $msg, "Subject", $subject, $invert
                         )
                      )
                    {
                        push( @matches, $id );
                        $CONFIG{ 'verbose' }
                          && print "\tmatch: found\n";
                    }
                }
            }
            @messages = @matches;
            $CONFIG{ 'verbose' }
              && print "\tFound "
              . scalar(@messages)
              . " matching message(s)\n";
        }
        elsif ( $token =~ /\!*from:(.*)/i )
        {

            #
            #  Filter all current messages to remove those that
            # don't match the given subject string.
            #
            my $sender = $1;

            #
            # Expansion:
            #
            #  "#"  -> " "
            #  "##" -> "#"
            #
            $sender =~ s/([^#])#([^#])/$1 $2/g if ($sender);
            $sender =~ s/##/#/g if ($sender);

            #
            #  Inverted search?
            #
            my $invert = 0;
            $invert = 1 if ( $token =~ /^\!/ );

            #
            #  Ensure we got an argument.
            #
            if ( !$sender )
            {
                print "Error - from: requires an argument\n";
                next;
            }

            #
            #  Dry run?  Stop here.
            #
            next if ( $CONFIG{ 'dry-run' } );

            if ( $CONFIG{ 'verbose' } )
            {
                if ($invert)
                {
                    print
                      "Looking messages with sender NOT matching: $sender\n";
                }
                else
                {
                    print "Looking messages with sender matching: $sender\n";
                }
            }

            my @matches;

            foreach my $id (@messages)
            {
                my $msg = getMessage( $imap, $id );

                if ($msg)
                {

                    #
                    #  Do the search
                    #
                    if ( matchMessageHeader( $msg, "From", $sender, $invert ) )
                    {
                        push( @matches, $id );
                        $CONFIG{ 'verbose' }
                          && print "\tmatch: found\n";
                    }
                }
            }
            @messages = @matches;
            $CONFIG{ 'verbose' }
              && print "\tFound "
              . scalar(@messages)
              . " matching message(s)\n";
        }
        elsif ( $token =~ /\!*To:(.*)/i )
        {

            #
            #  Filter all current messages to remove those that
            # don't match the given recipient
            #
            my $recipient = $1;

            #
            # Expansion:
            #
            #  "#"  -> " "
            #  "##" -> "#"
            #
            $recipient =~ s/([^#])#([^#])/$1 $2/g if ($recipient);
            $recipient =~ s/##/#/g if ($recipient);

            #
            #  Inverted search?
            #
            my $invert = 0;
            $invert = 1 if ( $token =~ /^\!/ );

            #
            #  Ensure we got an argument.
            #
            if ( !$recipient )
            {
                print "Error - to: requires an argument\n";
                next;
            }

            #
            #  Dry run?  Stop here.
            #
            next if ( $CONFIG{ 'dry-run' } );

            if ( $CONFIG{ 'verbose' } )
            {
                if ($invert)
                {
                    print
"Looking messages with recipient NOT matching: $recipient\n";
                }
                else
                {
                    print
                      "Looking messages with recipient matching: $recipient\n";
                }
            }

            my @matches;

            foreach my $id (@messages)
            {
                my $msg = getMessage( $imap, $id );

                if ($msg)
                {

                    #
                    #  Do the search
                    #
                    if ( matchMessageHeader( $msg, "To", $recipient, $invert ) )
                    {
                        push( @matches, $id );
                        $CONFIG{ 'verbose' }
                          && print "\tmatch: found\n";
                    }
                }
            }
            @messages = @matches;
            $CONFIG{ 'verbose' }
              && print "\tFound "
              . scalar(@messages)
              . " matching message(s)\n";
        }
        elsif ( $token =~ /\!*body:(.*)/i )
        {

            #
            #  Filter all current messages via a string in the body
            #
            my $body = $1;

            #
            # Expansion:
            #
            #  "#"  -> " "
            #  "##" -> "#"
            #
            $body =~ s/([^#])#([^#])/$1 $2/g if ($body);
            $body =~ s/##/#/g if ($body);

            #
            #  Inverted search?
            #
            my $invert = 0;
            $invert = 1 if ( $token =~ /^\!/ );

            #
            #  Ensure we got an argument.
            #
            if ( !$body )
            {
                print "Error - body: requires an argument\n";
                next;
            }

            #
            #  Dry run?  Stop here.
            #
            next if ( $CONFIG{ 'dry-run' } );

            if ( $CONFIG{ 'verbose' } )
            {
                if ($invert)
                {
                    print "Looking messages with body NOT matching: $body\n";
                }
                else
                {
                    print "Looking messages with body matching: $body\n";
                }
            }

            my @matches;

            foreach my $id (@messages)
            {
                my $msg = getMessage( $imap, $id );

                if ($msg)
                {

                    #
                    #  Do the search
                    #
                    if ( matchMessageBody( $msg, $body, $invert ) )
                    {
                        push( @matches, $id );
                        $CONFIG{ 'verbose' }
                          && print "\tmatch: found\n";
                    }
                }
            }
            @messages = @matches;
            $CONFIG{ 'verbose' }
              && print "\tFound "
              . scalar(@messages)
              . " matching message(s)\n";
        }
        elsif ( $token =~ /execonce:(.*)/i )
        {

            #
            #  Execute the named program only once, regardless of
            # the number of matches.
            #
            my $prog = $1;

            #
            #  Ensure we got an argument.
            #
            if ( !$prog )
            {
                print "Error - execonce: requires an argument\n";
                next;
            }

            #
            #  Dry run?  Stop here.
            #
            next if ( $CONFIG{ 'dry-run' } );


            $prog =~ s/^\s+//;
            $prog =~ s/\s+$//;


            my $count = scalar(@messages);
            if ($count)
            {
                $CONFIG{ 'verbose' } && print "Executing program: $prog\n";
                system($prog );
            }

        }
        elsif ( $token =~ /exec:(.*)/i )
        {

            #
            #  Execute the named program once for each selected
            # message.
            #
            my $prog = $1;

            #
            #  Ensure we got an argument.
            #
            if ( !$prog )
            {
                print "Error - exec: requires an argument\n";
                next;
            }

            #
            #  Dry run?  Stop here.
            #
            next if ( $CONFIG{ 'dry-run' } );

            $prog =~ s/^\s+//;
            $prog =~ s/\s+$//;

            #
            #  No option if there are no messages.
            #
            my $count = scalar(@messages);
            if ( !$count )
            {
                next;
            }


            $CONFIG{ 'verbose' } && print "Executing program: $prog\n";

            foreach my $id (@messages)
            {
                $CONFIG{ 'verbose' } && print "\t$id\n";
                my $msg = getMessage( $imap, $id );

                if ($msg)
                {
                    my ( $fh, $filename ) = tempfile();

                    foreach my $m (@$msg)
                    {
                        print $fh $m;
                    }
                    close($fh);

                    system("cat $filename | $prog");
                    unlink($filename);
                }
            }
        }
        elsif ( $token =~ /delete/i )
        {

            #
            #  No option if there are no messages.
            #
            my $count = scalar(@messages);
            if ( !$count )
            {
                next;
            }

            #
            #  Delete all currently selected messages.
            #
            $CONFIG{ 'verbose' } && print "Deleting messages\n";

            foreach my $id (@messages)
            {
                $CONFIG{ 'verbose' } && print "\t$id\n";
                $imap->delete($id);
            }
        }
        elsif ( $token =~ /dump/i )
        {

            #
            #  No option if there are no messages.
            #
            my $count = scalar(@messages);
            if ( !$count )
            {
                next;
            }

            #
            #  Dry run?  Stop here.
            #
            next if ( $CONFIG{ 'dry-run' } );


            #
            #  Dump details of the message
            #
            my $to      = '';
            my $from    = '';
            my $subject = '';

            foreach my $id (@messages)
            {
                my $msg = getMessage( $imap, $id );

                if ($msg)
                {
                    foreach my $line (@$msg)
                    {
                        $subject = $1 if ( $line =~ /^Subject: (.*)/i );
                        $from    = $1 if ( $line =~ /^From: (.*)/i );
                        $to      = $1 if ( $line =~ /^To: (.*)/i );
                    }

                    print <<EOF;
[$id]
	To: $to
	From: $from
	Subject: $subject
EOF
                }
            }

        }
        elsif ( $token =~ /move:(.*)/i )
        {

            #
            #  Move all selected messages to the specified folder.
            #
            my $dest = $1;

            #
            #  Ensure we got an argument.
            #
            if ( !$dest )
            {
                print "Error - move: requires an argument\n";
                next;
            }

            #
            #  Dry run?  Stop here.
            #
            next if ( $CONFIG{ 'dry-run' } );

            $dest =~ s/^\s+//;
            $dest =~ s/\s+$//;


            #
            #  No option if there are no messages.
            #
            my $count = scalar(@messages);
            if ( !$count )
            {
                next;
            }

            $CONFIG{ 'verbose' } && print "Moving messages to folder: $dest\n";

            foreach my $id (@messages)
            {
                print "\t$id\n";
                if ( $imap->copy( $id, $dest ) )
                {
                    $imap->delete($id);
                }
            }
        }
        elsif ( $token =~ /copy:(.*)/i )
        {

            #
            #  Copy all selected messages to the specified folder.
            #
            my $dest = $1;


            #
            #  Ensure we got an argument.
            #
            if ( !$dest )
            {
                print "Error - copy: requires an argument\n";
                next;
            }


            #
            #  Dry run?  Stop here.
            #
            next if ( $CONFIG{ 'dry-run' } );


            $dest =~ s/^\s+//;
            $dest =~ s/\s+$//;

            #
            #  No option if there are no messages.
            #
            my $count = scalar(@messages);
            if ( !$count )
            {
                next;
            }

            $CONFIG{ 'verbose' } && print "Copying messages to folder: $dest\n";

            foreach my $id (@messages)
            {
                $CONFIG{ 'verbose' } && print "\t$id\n";
                $imap->copy( $id, $dest );
            }
        }
        else
        {

            #
            #  Failed to find the token
            #
            print "WARNING: Uknown rule/token : $token\n";
        }
    }
}



=begin doc

  Primitive to return a list of message IDs which are messages that
 are not read.

=end doc

=cut

sub findUnread
{
    my ($count) = (@_);
    my $sh = $imap->{ sock };
    print $sh "A$count SEARCH unseen\r\n";

    my @matches;
    while ( my $resp = $sh->getline() )
    {
        last if ( $resp =~ /OK/ );

        if ( $resp =~ /SEARCH / )
        {
            if ($resp) {chomp($resp);}

            foreach my $tok ( split( / /, $resp ) )
            {
                if ( $tok =~ /^([0-9]+)/ )
                {
                    $tok = $1;
                }
                push( @matches, $tok ) if ( $tok =~ /^([0-9]+)$/ );
            }
        }
    }
    return (@matches);
}



=begin doc

  Primitive:  Find the messages IDs of messages which have been
 read in the current folder.

=end doc

=cut

sub findRead
{
    my ($count) = (@_);
    my $sh = $imap->{ sock };
    print $sh "A$count SEARCH seen\r\n";

    my @matches;
    while ( my $resp = $sh->getline() )
    {
        last if ( $resp =~ /OK/ );

        if ($resp) {chomp($resp);}

        if ( $resp =~ /SEARCH / )
        {
            foreach my $tok ( split( / /, $resp ) )
            {
                if ( $tok =~ /^([0-9]+)/ )
                {
                    $tok = $1;
                }

                push( @matches, $tok ) if ( $tok =~ /^([0-9]+)$/ );
            }
        }
    }

    return (@matches);
}



=begin doc

  Match a given value in the named header. Optionally invert the
 matching.

=end doc

=cut

sub matchMessageHeader
{
    my ( $message, $header, $value, $invert ) = (@_);

    # invert is optional - so ensure it is defined.
    $invert = 0 if ( !defined($invert) );

    # no message? no match.
    return 0 if ( ( !$message ) || ( !@$message ) );


    my $found = 0;

    foreach my $line (@$message)
    {
        next if ($found);

        if (    ( $line =~ /^\Q$header\E:(.*)/ )
             && ( !$found ) )
        {

            #
            #  OK we have the header.
            #
            my $val = $1;

            #
            #  Strip linefeeds / linebreaks
            #
            $val =~ s/[\r\n]//g;
            $CONFIG{ 'verbose' } && print "Found header '$header' - '$val'\n";

            if ($invert)
            {
                if ( $val !~ /$value/i )
                {
                    $CONFIG{ 'verbose' } && print "Matched: $value\n";
                    return 1;
                }
            }
            else
            {
                if ( $val =~ /$value/i )
                {
                    $CONFIG{ 'verbose' } && print "Matched: $value\n";
                    return 1;
                }
            }
        }
    }

    return 0;
}



=begin doc

  Does the body of the message match the given term?

=end doc

=cut

sub matchMessageBody
{
    my ( $message, $term, $invert ) = (@_);

    # invert is optional - so ensure it is defined.
    $invert = 0 if ( !defined($invert) );

    # no message? no match.
    return 0 if ( ( !$message ) || ( !@$message ) );


    my $body = 0;

    foreach my $line (@$message)
    {

        # strip newline/linefeed.
        $line =~ s/[\r\n]//g if ( defined($line) );

        # end of the header?
        $body = 1 if ( $line =~ /^$/ );

        if ( ($body) && ( $line =~ /$term/i ) )
        {
            $CONFIG{ 'verbose' } && print "Body line '$line' matches '$term'\n";

            return 1;
        }
    }
    return 0;
}



=begin doc

  Get a message from the imap store - and cache it.

=end doc

=cut

sub getMessage
{
    my ( $imap, $id ) = (@_);

    my $msg;

    #
    #  Is it cached?
    #
    if ( $CONFIG{ 'cache' } && ( -e $CONFIG{ 'cache' } . "/$id" ) )
    {
        $CONFIG{ 'verbose' }
          && print "Fetching message ID:$id from $CONFIG{'cache'}/$id\n";

        open( CACHE, "<", "$CONFIG{'cache'}/$id" )
          or die "Failed to read from cache $CONFIG{'cache'}/$id - $!";
        foreach my $line (<CACHE>)
        {
            push( @$msg, $line );
        }
        close(CACHE);
    }
    else
    {

        #
        #  Fetch
        #
        $msg = $imap->get($id);

        #
        #  Save to cache
        #
        if ( $CONFIG{ 'cache' } )
        {
            $CONFIG{ 'verbose' }
              && print "Saving message ID:$id to $CONFIG{'cache'}/$id\n";
            open( CACHE, ">", "$CONFIG{'cache'}/$id" )
              or die "Failed to write to cache $CONFIG{'cache'}/$id - $!";
            foreach my $line (@$msg)
            {
                print CACHE $line;
            }
            close(CACHE);
        }
    }

    return ($msg);
}

